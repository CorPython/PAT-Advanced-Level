# C++程序设计进阶

![· 设 置 私 有 成 员 的 目 的  弓 里 对 成 员 变 量 的 访 问 一 定 要 通 过 成 员 函 数 进 行  · 设 置 私 有 成 员 的 机 制 “ 隐 藏 ](file:////Users/shadow/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/C636E5F7-FE33-774A-9FCC-9AE06B9EB488.png)

一个二进制数的负数表示为它的反码+1

![2 ． printf("%x\n",-12 > > 2 ） 的 辅 出 结 果 是 ： 什 什 fd  ． 12 的 二 进 制 表 示  12 的 二 进 制 ： 00000000 00000000 00000000 00001100  反 码 ： 11111111 11111111 11111111 11110011  补 码 （ + 1 ）  ． 11111111 11111111 11111111 11110100  右 移 二 位 （ 右 移 两 位 ， 末 端 两 位 舍 去 ， 符 号 位 为 1 ， 左 端 补 两 个 1 ）  11111111 11111111 11111111 11111101 （ 十 六 进 制 表 示 为 什 什 fd ） ](file:////Users/shadow/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/8A6B3717-F060-334B-989A-0EAD0F4BD810.png)

 

- ![复 制 构 造 函 数 在 以 下 3 种 情 况 下 会 被 调 用 。  (1) 当 用 一 个 对 象 去 初 始 化 同 类 的 另 一 个 对 象 时 ， 会 引 发 复 制 构 造 函 数 被 调 用 。 如 下  面 的 两 条 语 句 都 会 引 发 复 制 构 造 函 数 的 调 用 ， 用 以 初 始 化 c2 ：  Complex c2(c1);  Complex c2 = Cl;  这 两 条 语 句 是 等 价 的 · 要 注 意 ， 第 二 条 语 句 是 初 始 化 语 句 ， 不 是 赋 值 语 句 · 赋 值 语 句 的 等 号  左 边 是 一 个 早 已 有 定 义 的 变 量 ， 赋 值 语 句 不 会 引 发 复 制 构 造 函 数 调 用 · 例 如 ：  Ccmple.* ， c2 ；  cl ． c2 ；  “ cl 一 c2 ； ” 这 条 语 句 不 会 引 发 复 制 构 造 函 数 调 用 ， 因 为 cl 早 己 生 成 ， 已 经 初 始 化 过 了 · ](file:////Users/shadow/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/6AD1DAD9-F74B-2940-B533-7EB91F317978.png)

 

- 对于成员对象 初始化列表中的参数是构造函数的参数      对于基本变量 初始化列表中的参数就是一个初始值

 

- ![封 闭 类 对 象 生 成 时 ， 先 执 行 所 有 成 员 对 象 的 构 造 函 数 ， 然 后 才 执 行 封 闭 类 自 己 的 构 造 函  敵 · 成 员 对 象 构 造 函 数 的 执 行 次 序 和 成 员 对 象 在 类 定 义 中 的 次 序 一 致 ， 与 它 们 在 构 造 函 数  初 始 化 列 表 中 出 现 的 次 序 无 关 · 当 封 闭 类 对 象 消 亡 时 ， 先 执 行 封 类 的 析 构 函 敵 ， 然 后 再 执  行 成 员 对 象 的 析 构 函 数 ， 成 员 对 象 析 构 函 数 的 执 行 次 序 和 构 造 数 的 执 行 次 序 相 反 ， 即 先 构  造 后 析 构 ， 这 是 C “ 语 言 处 理 此 类 次 序 问 题 的 一 般 规 律 · ](file:////Users/shadow/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/A7E9B410-38E0-F040-A818-BD93C1C7E93E.png) 

- this指针指向成员函数所作用的对象
- C++类构造函数初始化列表：
- ![C+ + 类 构 造 函 数 初 始 化 列 表  构 造 函 数 初 始 化 列 表 以 一 个 冒 号 开 始 ， 接 着 是 以 逗 号 分 隔 的 数 据 成 员 列 表 ， 每 个 数 据 成 员 后 面 跟 一 个 放 在 括 号 中 的 初 始 化 式 。 例 如 ．  闩  class CExample {  pu blic:  int a,  float b;  / / 构 造 函 数 初 始 化 列 表  CExample(): a(O),b(8.8)  / / 构 造 函 数 内 部 值  CExample()  b = 8 ． 8 ；  L ](file:////Users/shadow/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/2329CA52-9393-844B-914C-A076FCE9CCB0.png)

上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化。

初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。但有的时候必须用带有初始化列表的构造函数：

1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。

2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。 

赋值语句等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。

初始化数据成员与对数据成员赋值的含义是什么？有什么区别？

首先把数据成员按类型分类并分情况说明:

1.内置数据类型，复合类型（指针，引用）

​    在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的

2.用户定义类型（类类型）

​    结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作；调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

 

- 非引用的函数返回值不可以作为左值使用

- 高效的对象作为函数参数：

- - Void fun(const myclass &my) //使用引用避免调用复制构造函数造成额外开销，const保护 

- 尽管可以提前声明类，但是在一个类的定义出现之前，不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是可以的。
- 友元关系不能传递和继承。
- 类的非内联成员函数的函数体只能出现在某一个cpp文件中，不能放在头文件中被多个cpp文件包含，会重复定义；类的内联函数的函数体最好写在头文件中，就能在本文件包含的头文件中找到内联函数的代码，并将这些代码插入调用语句出，不会导致重复定义的错误。
- 任何生成对象的语句都要说明是用哪个构造函数初始化的，不说明则编译器认为对象是使用无参构造函数（即默认构造函数）或参数全部可以省略的构造函数初始化。
- 常量对象上面不能执行非常量成员函数，只能执行常量成员函数。
- 一般将运算符重栽为成员函数。
- 运算符重载为全局函数时，参数个数等于运算符目数；重载为成员函数时，参数个数等于运算符目数减一。后者更好。
- =只能重载为成员函数
- 前置++返回的是操作数的引用（可以作为左值），后置++返回的是操作数被修改前的复制品。
- 在基类中一般将需要隐藏的成员说明为保护成员而非私有成员。
- 多态类对象存储空间的最前端存放着指向虚函数表的指针（4个字节）虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表列出了该类的全部虚函数地址。
- 通过基类指针/基类引用对虚函数的调用实现多态。
- 在构造函数和析构函数中调用虚函数不是多态（是不合适的，因为会打乱构造和析构的一般顺序，造成潜在风险），因为编译时就已经确定可以调用的是哪个函数。如果本类有该函数，调用的就是本类的函数；如果本类没有，调用的就是直接基类的函数。如果直接基类没有，调用的就是间接基类的函数，以此类推。
- 只要基类中的某个函数被声明为虚函数，则派生类中的同名、同参数表的成员函数即使前面什么也不写，也自动成为虚函数。
- 在公有派生的情况下，派生类的对象可以赋值给基类对象，派生类的对象可以用来初始化基类引用，派生类的指针可以赋值给基类指针。
- 只要基类的析构函数是虚构函数，那么派生类中的析构函数不论是否用virtual关键字都自动成为虚析构函数。一般来说，一个类如果定义了虚函数，最好将析构函数也定义成虚函数。析构函数可以是虚函数，构造函数不能是虚函数。
- 纯虚函数的写法：在函数声明后面加=0，不写函数体。纯虚函数其实不存在，引入是为了便于实现多态。包含纯虚函数的抽象类不能生成独立的对象。
- 为了避免多继承的二义性，从ios抽象类派生出的istream和ostream均采用虚继承。
- 打开文件，绑定文件与文件流对象，通过对象操作文件。
- 打开文件的两种方法：调用流对象的open成员函数，定义文件流对象时，通过构造函数打开文件。
- 编译器由模版自动生成函数的过程叫模版的实例化。由模版实例化得到的函数称为模版函数。 （各种相互继承派生交友……很强了）

标准模版库STL(PAT考试神器)

- STL基本概念：

- - 容器：储存数据的类模版。分为顺序容器，关联容器，三种容器适配器（栈，队列，优先级队列）
  - 迭代器：存取容器中元素的工具，本质是指针
  - 算法：操作容器中元素的函数模版

- 任何两个容器对象，只要他们的类型相同，就可以进行“词典型”比较。（元素ascii码，元素个数）

- 两个随机访问迭代器p1,p2可以进行大小对比，p1<p2的含义是p1经过若干次++操作后就会等于p2。顺序容器元素的地址是连续的，关联容器不是，所以不能比大小。

- 只有随机访问迭代器可以进行下标操作。

- erase返回被删除元素后面那个元素的迭代器

- 队列的访问top和删除pop操作只能在队头进行，添加操作push只能在队尾进行，不能访问队列中的元素。

### 总而言之，C++真是博大精深～

![c++](/Users/shadow/Desktop/c++.jpg)

参考资料：

郭炜《新标准C++程序设计》以及cousera配套课程