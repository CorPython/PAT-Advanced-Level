# C++程序设计进阶 

赋值语句等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。

初始化数据成员与对数据成员赋值的含义是什么？有什么区别？

首先把数据成员按类型分类并分情况说明:

1.内置数据类型，复合类型（指针，引用）

在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的

2.用户定义类型（类类型）

结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作；调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

 

- 非引用的函数返回值不可以作为左值使用

- 高效的对象作为函数参数：

- - Void fun(const myclass &my) //使用引用避免调用复制构造函数造成额外开销，const保护 

- 尽管可以提前声明类，但是在一个类的定义出现之前，不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是可以的。
- 友元关系不能传递和继承。
- 类的非内联成员函数的函数体只能出现在某一个cpp文件中，不能放在头文件中被多个cpp文件包含，会重复定义；类的内联函数的函数体最好写在头文件中，就能在本文件包含的头文件中找到内联函数的代码，并将这些代码插入调用语句出，不会导致重复定义的错误。
- 任何生成对象的语句都要说明是用哪个构造函数初始化的，不说明则编译器认为对象是使用无参构造函数（即默认构造函数）或参数全部可以省略的构造函数初始化。
- 常量对象上面不能执行非常量成员函数，只能执行常量成员函数。
- 一般将运算符重栽为成员函数。
- 运算符重载为全局函数时，参数个数等于运算符目数；重载为成员函数时，参数个数等于运算符目数减一。后者更好。
- =只能重载为成员函数
- 前置++返回的是操作数的引用（可以作为左值），后置++返回的是操作数被修改前的复制品。
- 在基类中一般将需要隐藏的成员说明为保护成员而非私有成员。
- 多态类对象存储空间的最前端存放着指向虚函数表的指针（4个字节）虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表列出了该类的全部虚函数地址。
- 通过基类指针/基类引用对虚函数的调用实现多态。
- 在构造函数和析构函数中调用虚函数不是多态（是不合适的，因为会打乱构造和析构的一般顺序，造成潜在风险），因为编译时就已经确定可以调用的是哪个函数。如果本类有该函数，调用的就是本类的函数；如果本类没有，调用的就是直接基类的函数。如果直接基类没有，调用的就是间接基类的函数，以此类推。
- 只要基类中的某个函数被声明为虚函数，则派生类中的同名、同参数表的成员函数即使前面什么也不写，也自动成为虚函数。
- 在公有派生的情况下，派生类的对象可以赋值给基类对象，派生类的对象可以用来初始化基类引用，派生类的指针可以赋值给基类指针。
- 只要基类的析构函数是虚构函数，那么派生类中的析构函数不论是否用virtual关键字都自动成为虚析构函数。一般来说，一个类如果定义了虚函数，最好将析构函数也定义成虚函数。析构函数可以是虚函数，构造函数不能是虚函数。
- 纯虚函数的写法：在函数声明后面加=0，不写函数体。纯虚函数其实不存在，引入是为了便于实现多态。包含纯虚函数的抽象类不能生成独立的对象。
- 为了避免多继承的二义性，从ios抽象类派生出的istream和ostream均采用虚继承。
- 打开文件，绑定文件与文件流对象，通过对象操作文件。
- 打开文件的两种方法：调用流对象的open成员函数，定义文件流对象时，通过构造函数打开文件。
- 编译器由模版自动生成函数的过程叫模版的实例化。由模版实例化得到的函数称为模版函数。 （各种相互继承派生交友……很强了）

标准模版库STL(PAT考试神器)

- STL基本概念：

- - 容器：储存数据的类模版。分为顺序容器，关联容器，三种容器适配器（栈，队列，优先级队列）
  - 迭代器：存取容器中元素的工具，本质是指针
  - 算法：操作容器中元素的函数模版

- 任何两个容器对象，只要他们的类型相同，就可以进行“词典型”比较。（元素ascii码，元素个数）

- 两个随机访问迭代器p1,p2可以进行大小对比，p1<p2的含义是p1经过若干次++操作后就会等于p2。顺序容器元素的地址是连续的，关联容器不是，所以不能比大小。

- 只有随机访问迭代器可以进行下标操作。

- erase返回被删除元素后面那个元素的迭代器

- 队列的访问top和删除pop操作只能在队头进行，添加操作push只能在队尾进行，不能访问队列中的元素。

### 总而言之，C++真是博大精深～

![image](https://github.com/merelydust/PAT-Advanced-Level/blob/master/image/c%2B%2B.jpg)

参考资料：

郭炜《新标准C++程序设计》以及cousera配套课程
